#include <algorithm>
#include <array>
#include <cstring>
#include <string_view>

#include "mmml/util/html_entities.hpp"

namespace mmml {
namespace {

struct Character_Reference {
    char8_t name[34];
    unsigned char name_length;
    char32_t code_points[2];

    [[nodiscard]]
    constexpr std::u8string_view name_as_string() const noexcept
    {
        return { name, name_length };
    }

    [[nodiscard]]
    constexpr std::u32string_view code_points_as_string() const noexcept
    {
        return { code_points, code_points[1] != 0 ? 2uz : 1uz };
    }
};

constexpr Character_Reference references[] {
#include "html_entities_autogenerated.cpp" // NOLINT
};

static_assert(std::ranges::is_sorted(references, {}, &Character_Reference::name_as_string));

const Character_Reference* character_reference_by_name(std::u8string_view name) noexcept
{
    const auto* const it
        = std::ranges::lower_bound(references, name, {}, &Character_Reference::name_as_string);
    if (it == std::end(references) || it->name_as_string() != name) {
        return nullptr;
    }
    return &*it;
}

} // namespace

constinit const auto html_character_names = [] {
    std::array<std::u8string_view, std::size(references)> result;
    for (std::size_t i = 0; i < result.size(); ++i) {
        result[i] = references[i].name_as_string();
    }
    return result;
}();

std::array<char32_t, 2> code_points_by_character_reference_name(std::u8string_view name) noexcept
{
    if (const auto* const result = character_reference_by_name(name)) {
        return std::to_array(result->code_points);
    }
    return {};
}

std::u32string_view string_by_character_reference_name(std::u8string_view name) noexcept
{
    if (const auto* const result = character_reference_by_name(name)) {
        return result->code_points_as_string();
    }
    return {};
}

} // namespace mmml
