\macro[\cm{...}]{\code[cowel]{\put}}
\macro[\ch{...}]{\code[html]{\put}}
\macro[\dir{...}]{\cm{\hl[markup-tag]{\\\put}}}
\macro[\codepoint{...}]{U+\put\c{nbsp}(\tt{\U{\put}})}

\there[std.head]{
\html-title{COWEL - Compact Web Language Documentation}
}

\h1{Compact Web Language (COWEL)}

\html-div[id=github]{
\style{
h1 {
    margin-bottom: 0;
}

#github {
    font-size: 125%;
    margin-bottom: 3em;
}
}
\ref[https://github.com/eisenwave/cowel]
}

\h2[listed=no]{Contents}

\make-contents

\h2{Introduction}

COWEL is a markup language with TeX-like syntax,
intended to generate HTML documents,
mainly for proposals and technical text.
Many of its features are purpose-built for use in WG21,
such as for writing C++ proposals.

\example{
The following COWEL code ...
\codeblock[cowel]{
Hello, \\strong{strong} world!
}
... generates the HTML ...
\codeblock[html]{
Hello, <strong>strong</strong> world!
}
... which renders as:
\indent{
Hello, \strong{strong} world!
}
}

\h2{Getting started}

COWEL is still early in development,
and not available in any package manager yet.
To install it and run COWEL:
\codeblock[sh]{
git clone https://github.com/Eisenwave/cowel.git --recursive
cd cowel
cmake -B build
cmake --build build
./build/cowel-cli INPUT.cowel OUTPUT.html
}

\h2{Motivation}

Many similar tools (mpark/wg21, bikeshed, etc.)
are based on Markdown.
This makes them beginner-friendly,
but advanced formatting requires heavy use of Markdown extensions
or mixed use of Markdown and HTML tags.
Metadata such as bibliographies, document information, etc.
also rely on yet another format (e.g. JSON, YAML).

This makes these tools difficult to master and makes the design incoherent.
Why do we need three languages glued together just to format our documents?

COWEL is the missing middle, the missing link.
It makes producing HTML a natural part of the language,
lets you specify metadata,
and more, all in one, simple syntax.

\h2{Syntax in a nutshell}

COWEL has a minimalistic but powerful syntax,
built on top of only three syntactical constructs:
\ul{
\item{\cm{\\various-directives[positional args, named-args = 0]{and content}}}
\item{\cm{Text.}}
\item{Escape sequences, such as \cm{\\\U{7B}}, \cm{\\\U{7D}}, \cm{\\\\}, etc.}
}

There is no special syntax besides that,
meaning that as long as some bit of code doesn't contain a \cm{\\},
it's all interpreted as plaintext.
This makes COWEL exceptionally suited to nest other languages inside of it in code blocks etc.

\h3{Whitespace}

COWEL translates very directly into HTML.
Any whitespace in text is preserved exactly as is.
The way that whitespace is processed then depends on the produced HTML and how it is CSS-styled.

\example{
At a top level, whitespace is merged and line breaks are rendered like spaces:
\codeblock[cowel]{
This displays on one line
because line breaks render like spaces.
}
Generated HTML:
\codeblock[html]{
<p>This displays on one line
because line breaks render like spaces.</p>
}
Rendered output:
\indent{This displays on one line because line breaks render like spaces.}
}

\h3{Paragraph splitting}

At the top-level in the document and within the content of certain directives,
\dfn{paragraph splitting} takes place.
All content in COWEL is either \dfn{inline content}, \dfn{block content}, or \dfn{meta content}.
Text and escape sequences are inline content,
and directives are sometimes inline and sometimes block content.
Certain directives (e.g. \dir{comment}) that don't generate anything rendered are meta content.

The process of paragraph splitting works as follows:
\ul{
\item{
Blank-line-separated blocks of inline content is wrapped in in \ch{<p>...</p>} tags.
Meta content is not counted as a blank line, so it "continues" inline content,
but no effort is made to wrap it in \ch{<p>...</p>}.
}
\item{
Block content stays untouched, i.e. it is not wrapped in \ch{<p>...</p>}.
However, it also terminates prior inline content, like a blank line.
}
}

\example{
COWEL markup:
\codeblock[cowel]{
First paragraph.

Second paragraph.
\\blockquote{This is a block directive.}
}
Generated HTML:
\codeblock[html]{
<p>First paragraph.</p>

<p>Second paragraph.</p>
<blockquote>This is a block directive.</blockquote>
}
}

\h2{Directives}

A \dfn{directive} is a way of generating plaintext, HTML, both, or neither.
You can think of it as a "command" or "function call".

Every directive has three parts:
\ul{
\item{The \cm{\\directive-name} selects a specific directive to be processed.}
\item{
An optional \cm{[comma-separated, positional arguments, named-arguments = ...]}
provides additional inputs to the directive.
}
\item{
An optional \cm{{block of content}} provides a "main input" to a directive.
}
}

\h3{Directive names}

A \dfn{directive name} selects a specific directive to be processed.
The name begins with a \cm{\\} character,
followed by
\ref[https://html.spec.whatwg.org/dev/custom-elements.html#valid-custom-element-name]{
any character that is valid in an HTML (custom) tag name.
}
This includes any alphanumeric ASCII characters,
\codepoint{002D}, \codepoint{002E}, \codepoint{005F},
and various Unicode characters.

\tip{
You can use an empty block of content to "cut a name short":
\codeblock[cowel]{
Thisisavery\\wbr{}longword.
}
Doing so is equivalent to writing \cm{\\wbr} and \cm{longword} immediately following one another.
}

\h3{Directive arguments}

\dfn{Directive arguments} can be \dfn{positional arguments} or \dfn{named arguments}.
Arguments are separated by commas.
Unlike anywhere else, whitespace surrounding directive arguments is ignored.

Arguments provide additional information to a directive.

\example{
Often, arguments are converted to HTML attributes.
\codeblock[cowel]{
\\b[id = abc]{Bold text.}
}
Generated HTML:
\codeblock[html]{
<b id=abc>Bold text.</b>
}
}

\h4{Named arguments}

Named arguments are of the form
\cm{name = value}, where spaces anywhere around \cm{name} and \cm{value} are ignored.
Named arguments are matched to directive parameters before any positional arguments,
meaning that positional arguments fill the remaining unmatched arguments.

Argument names can consist of any character, except
ASCII control characters,
U+0020\c{nbsp}SPACE,
\codepoint{0022},
\codepoint{0027},
\codepoint{002C},
\codepoint{002F},
\codepoint{003D},
\codepoint{003E},
\codepoint{005B},
\codepoint{005C},
\codepoint{005D},
\codepoint{007B},
\codepoint{007D},
and noncharacters.

\tip{
If you want to provide a positional argument that is \cm{name = value} instead,
you can do so by writing:
\codeblock[cowel]{
\\comment{"name = value" as a positional argument}
\\xyz[name \\= value]
\\comment{named argument with name "name" and value "value"}
\\xyz[name = value]
}
Only the literal \cm{=} character can be used for named arguments,
not its escaped variant \cm{\\=}.
}

\h4{Positional arguments}

Positional arguments are content just like any other content,
except that an unbalanced closing \codepoint{005D} or a \codepoint{002C}
ends the content.

\tip{
You can use escape sequences to continue otherwise ended content.
\codeblock[cowel]{
\\xyz[hello, world]  \\comment{Two positional arguments}
\\xyz[hello\\, world] \\comment{One positional argument containing a comma.}

\\xyz[hello[]world]  \\comment{OK, [] is balanced and included in single argument}
\\xyz[hello\\]world]  \\comment{OK}
\\xyz[hello\\[world]  \\comment{OK}
\\xyz[hello[world]   \\comment{error: unterminated arguments}
}
}

\h3{Directive content}

The \dfn{directive content} is the primary input to a directive.
It is delimited by a '\tt{\{}' and ends with a \em{matching} closing '\tt{\}}'.
This means that you can have opening and closing braces inside text,
but they need to be balanced.

\example{
COWEL markup:
\codeblock[cowel]{
\\b{Bold text { with braces }.}
}
Generated HTML:
\codeblock[html]{
<b>Bold text { with braces }.</b>
}
}

Escape sequences don't participate in this "brace matching",
so they can be used to literally produce a brace character.
\example{
COWEL markup:
\codeblock[cowel]{
\\b{Bold text \\\U{7B} with brace.}
}
Generated HTML:
\codeblock[html]{
<b>Bold text \U{7B} with brace.</b>
}
}

Unlike in the directive arguments,
whitespace is not trimmed.
\example{
COWEL markup:
\codeblock[cowel]{
\\b{bold} \\i{ italic }
}
Generated HTML:
\codeblock[html]{
<b>bold</b> <i> italic </i>
}
}

\note{
Only one such block of content can be provided, unlike in TeX,
which has a similar syntax,
but permits multiple blocks. Each block is separated by a pair of braces.
}

\h3{Directive processing}

Unlike in typical programming languages,
where the input to a function is processed at the call site and the resulting values
are passed into the function,
COWEL directives have \em{absolute} control over their inputs and how they are processed.

Say you have a JavaScript function:
\codeblock[js]{
function f(x) {
    console.log(x);
}
f(2 + 2);
}
\code[js]{f} has no idea that its input was originally \code[js]{2 + 2}.
It only sees the value \code[js]{4} and prints it, "oblivious to the outside".

COWEL follows a different model:
\codeblock[cowel]{
\\comment{\\b{x}}
}
No \ch{<b>} tag is ever generated because \cm{\\b{x}} is never processed.
\dir{comment} is not magical feature;
it simply has control over all of its contents and arguments,
and it can choose not to process them.

You can even make a \dir{comment2} directive that works
just like \dir{comment} yourself:
\codeblock[cowel]{
\\macro[\\comment2]{}
}

\h2{Contexts and output}

There are two types of contexts: \dfn{plaintext contexts} and \dfn{HTML contexts}.
These control what directives (and other content) will generate.

\example{
The COWEL text \cm{&} will be converted to \tt{&} literally in a plaintext context,
and to \ch{&amp;} in an HTML context.
}


Any directive is capable of generating either plaintext or HTML,
and the output may be substantially different depending on the context.

\example{
The \dir{c} directive is used to generate HTML character references, aka "HTML entities".
It converts its input to plaintext to determine the chosen character.
Within such a plaintext context,
directives like \dir{b} will simply output their content as plaintext:
\codeblock[cowel]{
\\c{\\b{Omega}} \\c{Omega}
}
Generated HTML:
\codeblock[html]{
&Omega; &Omega;
}
Also, \dir{c} will only emit an HTML entity in an HTML context.
In a plaintext context (such as in the input to \dir{c}), it outputs the character directly.
For example, if we write:
\codeblock[cowel]{
\\c{\\c{Omega}}
}
The generated (malformed) HTML is:
\codeblock[html]{
&\c{Omega};
}
}

\h2{Themes}

COWEL outputs documents that can be viewed in \dfn{light mode} and \dfn{dark mode}.

When the document is opened with support for JavaScript,
there is an button in the top-right that can be used to switch between three modes:
\ul{
\item{Sync the theme with the OS (default)}
\item{Light mode (ignoring system preference)}
\item{Dark mode (ignoring system preference)}
}

Forced light/dark mode works by adding a \tt{light} or \tt{dark}
class to the \ch{<html>} element in the DOM.

\important{
If you want to customize colors with CSS,
remember to make them respond to theme and OS preference changes.

For reference, you can look at the CSS in the COWEL source code to see how it's done properly.
}

\h2{List of directives}

\h3{Comments}

Unlike many other markup languages,
COWEL has no dedicated syntax for comments.
However, there exists a \dir{comment} directive which you can use to put comments into code.

\h4{\dir{comment} \c{mdash} Comments}

The \dir{comment} directive does not process its arguments or content.
It outputs no plaintext or HTML.

\example{
While comments don't output anything,
\ref[#paragraph-splitting] is based on blank lines in the source,
so comments don't split paragraphs:
\codeblock[cowel]{
Text
\\comment{This is \\directive{comment} content.}
Text
}
Generated HTML:
\codeblock[html]{
<p>Text

Text</p>
}
}

\h3{Text formatting}

COWEL allows for basic text formatting using various directives.
Many of the formatting directives are some direct equivalent of an HTML element.
For these, there is a fixed HTML element that will always be used.
You can rely on this when adding custom CSS.

\table{
\tr{
    \th{Directive}
    \th{HTML}
    \th{Renders as}
}
\tr[id=dir-b]{
    \td{\cm{\\b{...}}}
    \td{\ch{<b>...</b>}}
    \td{\b{Bold text}}
}
\tr[id=dir-cite]{
    \td{\cm{\\cite{...}}}
    \td{\ch{<cite>...</cite>}}
    \td{\cite{Name of cited work}}
}
\tr[id=dir-del]{
    \td{\cm{\\del{...}}}
    \td{\ch{<del>...</del>}}
    \td{\del{Deleted text}}
}
\tr[id=dir-dfn]{
    \td{\cm{\\dfn{...}}}
    \td{\ch{<dfn>...</dfn>}}
    \td{\dfn{Definition}}
}
\tr[id=dir-em]{
    \td{\cm{\\em{...}}}
    \td{\ch{<em>...</em>}}
    \td{\em{Emphasized text}}
}
\tr[id=dir-gterm]{
    \td{\cm{\\gterm{...}}}
    \td{\i{unspecified}}
    \td{\gterm{grammar-term}}
}
\tr[id=dir-i]{
    \td{\cm{\\i{...}}}
    \td{\ch{<i>...</i>}}
    \td{\i{Italic text}}
}
\tr[id=dir-ins]{
    \td{\cm{\\ins{...}}}
    \td{\ch{<ins>...</ins>}}
    \td{\ins{Inserted text}}
}
\tr[id=dir-kbd]{
    \td{\cm{\\kbd{...}}}
    \td{\ch{<kbd>...</kbd>}}
    \td{\kbd{Ctrl} + \kbd{Keyboard key}}
}
\tr[id=dir-mark]{
    \td{\cm{\\mark{...}}}
    \td{\ch{<mark>...</mark>}}
    \td{\mark{Marked/highlighted}}
}
\tr[id=dir-o]{
    \td{\cm{\\o{...}}}
    \td{\i{unspecified}}
    \td{\o{Oblique text}}
}
\tr[id=dir-q]{
    \td{\cm{\\q{...}}}
    \td{\ch{<q>...</q>}}
    \td{\q{Quoted text}}
}
\tr[id=dir-s]{
    \td{\cm{\\s{...}}}
    \td{\ch{<s>...</s>}}
    \td{\s{Struck text}}
}
\tr[id=dir-samp]{
    \td{\cm{\\samp{...}}}
    \td{\ch{<samp>...</samp>}}
    \td{\samp{Sample output}}
}
\tr[id=dir-sans]{
    \td{\cm{\\sans{...}}}
    \td{\i{unspecified}}
    \td{\sans{Sans-serif font}}
}
\tr[id=dir-serif]{
    \td{\cm{\\serif{...}}}
    \td{\i{unspecified}}
    \td{\serif{Serif font}}
}
\tr[id=dir-small]{
    \td{\cm{\\small{...}}}
    \td{\ch{<small>...</small>}}
    \td{\sub{Small text}}
}
\tr[id=dir-sub]{
    \td{\cm{\\sub{...}}}
    \td{\ch{<sub>...</sub>}}
    \td{\sub{Subscript}}
}
\tr[id=dir-sup]{
    \td{\cm{\\sup{...}}}
    \td{\ch{<sup>...</sup>}}
    \td{\sup{Superscript}}
}
\tr[id=dir-strong]{
    \td{\cm{\\strong{...}}}
    \td{\ch{<strong>...</strong>}}
    \td{\b{Strong text}}
}
\tr[id=dir-tt]{
    \td{\cm{\\tt{...}}}
    \td{\i{unspecified}}
    \td{\tt{Teletype/monospace font}}
}
\tr[id=dir-var]{
    \td{\cm{\\var{...}}}
    \td{\ch{<var>...</var>}}
    \td{\var{Variable name}}
}
\tr[id=dir-u]{
    \td{\cm{\\u{...}}}
    \td{\ch{<u>...</u>}}
    \td{\u{Underlined text}}
}
}

All such \dfn{formatting directives}
convert all named arguments directly into HTML attributes.

\note{
By default, a substantial amount of directives are styled the same way.
For example, \dir{cite}, \dir{var}, \dir{i} and \dir{em} are all italic.
Both \dir{strong} and \dir{b} are bold.
Both \dir{tt} and \dir{samp} use teletype font.

However, you can customize the style; see \ref[#dir-style].
}

\note{
The difference between oblique (\dir{o}) and italic (\dir{i}) text
is that oblique text is merely slanted,
while italic text is fundamentally a different font with different characters.
}

\h3[id=code]{Code and syntax highlighting}

COWEL uses
\ref[https://github.com/Eisenwave/ulight]{µlight}
for syntax highlighting.
While the set of supported language is relatively small,
the highlighter is ultra-light, extremely fast, and
deals with modern C++ features correctly.

\h4[id=dir-code]{\dir{code} \c{mdash} Inline code}

The \dir{code} directive produced syntax-highlighted text in code font.

\dl{
\dt{Arguments}
\dd{
\ul{
\item{\tt{lang} (plaintext) \c{mdash} the syntax highlighting language.}
\item{\tt{nested} (yes/no) \c{mdash} whether whether to omit \ch{<code>} tags.}
\item{\tt{prefix} (plaintext) \c{mdash} code before the input from the view of the highlighter.}
\item{\tt{suffix} (plaintext) \c{mdash} code after input from the view of the highlighter.}
}
}

\dt{Input content}
\dd{
The input to a \dir{code} directive is a plaintext context.
However, there are special rules for formatting directives
and pure plaintext directives (see below).
}

\dt{HTML output}
\dd{
In an HTML context, the \dir{code} takes the input source code,
applies syntax highlighting,
and outputs the result surrounded by \ch{<code>...</code>}.
}

\dt{Plaintext output}
\dd{
In a plaintext context, \dir{code} simply outputs the input source code.
}

\dt{Display style}
\dd{Inline}
}

\example{
COWEL markup:
\codeblock[cowel]{
\\code[cpp]{123}
}
This applies C++ syntax highlighting, and generates HTML.
The \ch{<h->} tags are an implementation detail and may be subject to change.
\codeblock[html]{
<code><h- data-h=num>123</h-></code>
}
}

\h5{Manual nested highlighting}

The \tt{nested} parameter is a plaintext context,
which accepts either \tt{yes} or \tt{no}, where \tt{no} is the default.
When enabled, the surrounding \ch{<code>} tags are omitted,
which makes it suitable for nesting languages within other \dir{code} or \dir{codeblock}
directives.

\example{
You can nest JSON inside of a C++ string literal as follows:
\codeblock[cowel]{\unprocessed{
Call: \code[cpp]{out.write_json("\code[json,nested=yes]{{"x":123,"y":true,"z":null}}")}
}}
This renders as follows:
\indent{
Call: \code[cpp]{out.write_json("\code[json,nested=yes]{{"x":123,"y":true,"z":null}}")}
}
}

Note that by default,
you may often not even notice a visual difference between using the \tt{nested}
parameter and not using it.
However, the difference would be obvious once you want to style \ch{<code>} elements
to have borders, background color, padding, and other such styling features.
\tt{nested=yes} directly emits the highlighting HTML elements,
which is more composable.

\h5{Highlighting prefix and suffix}

The \tt{prefix} and \tt{suffix} parameters are plaintext contexts
which can be used to further control highlighting.
Especially with inline code,
the highlighting depends on the surrounding code.

\tt{prefix} and \tt{suffix} can be used to provide that surrounding code,
without becoming part of the highlighted output.

\example{
Using \tt{prefix},
we can control whether a JSON string is interpreted as a markup key,
or as a string value:
\codeblock[cowel]{\literally{
In JSON, there are \code[json,prefix=\{]{"keys"} and \code[json]{"values"}.
}}
This renders as:
\indent{
In JSON, there are \code[json,prefix=\{]{"keys"} and \code[json]{"values"}.
}
Notice that the color of \code[json,prefix=\{]{"keys"} is different because it is interpreted
as if it was positioned like:
\codeblock[json]{
\{"keys"
}
}


\h5{Further advice on highlighting}

\tip{
Writing \dir{code} directives directly is often too tedious,
so you'll likely want to define a macro to make this easier:
\codeblock[cowel]{
\\comment{Defines a \\js directive that can be used in place of \\code[js] from now on:}
\\macro[\\js]{\\code[js]{\\put}}
Let's highlight \\js{var} in JavaScript.
}
}

\h4[id=dir-codeblock]{\dir{codeblock} \c{mdash} Code blocks}

The \dir{codeblock} directive works exactly like \dir{code},
but it is a block directive, not an inline directive.

Additionally, code blocks render using borders and a dark background by default.
This can be controlled using the \tt{borders}.

\example{
\codeblock[cowel]{
\\codeblock[js]{
// Borders enabled
let x = 0;
}
\\codeblock[js,borders=no]{
// Borders disabled
let x = 0;
}
}
This renders as:
\codeblock[js]{
// Borders enabled
let x = 0;
}
\codeblock[js,borders=no]{
// Borders disabled
let x = 0;
}
}

\h4[id=dir-hl]{\dir{hl} \c{mdash} Syntax highlight override}

The \dir{hl} directive forces certain syntax highlighting to be applied to some text;
it is a manual override for when automatic syntax highlighting is insufficient or broken.
It displays as inline content and wraps its content (which is an HTML context)
in the appropriate syntax highlighting tags.

It has a single \tt{name} argument, which is the µlight \dfn{long name} for a highlight type.
You can obtain a list of possible long names at
\ref[https://github.com/Eisenwave/ulight/blob/main/include/ulight/ulight.h]{\tt{ulight.h}}
from the definition of \code[cpp]{enum ulight_highlight_type}.
The long name is the enumerator name without the \tt{ULIGHT_HL} prefix,
all lowercase, and with hyphens instead of underscores.

\example{
It is possible to mix automatic syntax highlighting with manual overrides:
\codeblock[cowel]{
\\comment{_Int128 is manually highlighted as a type keyword,
          and x is automatically highlighted as an identifier}
\\code[c]{\\hl[keyword-type]{_Int128} x}
}
This generates the HTML (subject to change):
\codeblock[html]{
<code><h- data=h=kw_type>_Int128</h-> <h- data-h=id>x</h-></code>
}
It renders as \code[c]{\hl[keyword-type]{_Int128} x}.
}

\note{
While it is also possible to produce the highlighting tags using
\cm{\\html-h-[data-h=kw_type]{_Int128}},
the "short names" (\cm{kw_type}) are not stable, i.e. they are more likely to change.
Only µlight long names should be used directly.
}

\h4[id=dir-pre]{\dir{pre} \c{mdash} Preformatted blocks}

The \dir{pre} directive contains pre-formatted content.
It can be used to contain code, however, there is no syntax highlighting in a \dir{pre} block.

\example{
COWEL markup:
\codeblock[cowel]{
\\pre{
Hello, world!
=============
    a b c
}
}
This renders as:
\pre{
Hello, world!
=============
    a b c
}
}

\todo{
Unlike \dir{codeblock}, \dir{pre} currently does not support the \tt{borders=no} option.
This will be added in the future.
}

\h4[id=dir-literally]{\dir{literally} \c{mdash} Treat input literally as text}

The \dir{literally} directive treats its input source code as plain text,
even if it contains directives or escape sequences.
It outputs the given input source code as text.

Its content is an unprocessed context,
and it takes no arguments.

\example{
COWEL markup:
\codeblock[cowel]{
\literally{\pre{\literally{
This \comment{comment} \{ is taken literally \}!
}}}
}
This renders as:
\pre{\literally{
This \comment{comment} \{ is taken literally \}!
}}
}

\note{
\dir{put} pseudo-directives in macros are still processed,
even inside \dir{literally} blocks
because \dir{macro} replaces any appearances of \dir{put} with the given content,
disregarding the semantics of any directives nested within.
}

\h4[id=dir-unprocessed]{\dir{unprocessed} \c{mdash} Suppress directive processing}

The \dir{unprocessed} directive works just like \dir{literally},
except that escape sequences are processed into their escaped characters.

\example{
COWEL markup:
\codeblock[cowel]{\literally{
\pre{\unprocessed{
This \comment{comment} \{ is unprocessed \}!
}}
}}
This renders as:
\pre{\unprocessed{
This \comment{comment} \{ is unprocessed \}!
}}
}

\tip{
\dir{unprocessed} and (to a lesser extent) \dir{literally} are very useful for nesting
code inside COWEL that already contains underscores.
For example, \cm{\\n} is an escape sequence for newline characters in many languages,
and it may be annoying if it gets interpreted as an \dir{n} directive:
\codeblock[cowel]{\unprocessed{
\codeblock[cpp]{\unprocessed{
std::string_view s = "Several\nLines\nof\nCode.";
}}
}}
This renders as:
\codeblock[cpp]{\unprocessed{
std::string_view s = "Several\nLines\nof\nCode.";
}}
Notice that COWEL technically parses a \dir{nLines} directive instead of just \dir{n},
which is the part that turns into a newline escape sequence in the C++ code block.
However, that is ultimately irrelevant for syntax highlighting
because the source characters of \dir{nLines} are taken as text,
and then split up according to C++ syntax.
}

\note{
\dir{put} pseudo-directives in macros are still processed,
even inside \dir{unprocessed} blocks
because \dir{macro} replaces any appearances of \dir{put} with the given content,
disregarding the semantics of any directives nested within.
}

\h3[id=math]{Math}

In recent years, browser support for
\ref[https://developer.mozilla.org/en-US/docs/Web/MathML]{MathML}
within HTML has become widespread.
COWEL relies entirely on the browser for properly rendering math as MathML,
which is very simple and lightweight,
but not as portable as "baking" the math into an SVG.

\vset[x-over-2]{<math display=inline>
  <mfrac>
    <mi>x</mi>
    <mn>2</mn>
  </mfrac>
</math>}

\example{
If you have existing MathML, you can embed their content using \dir{html} or \dir{htmlblock}:
\codeblock[cowel]{
Math
\\html{
\vget[x-over-2]
}
in a sentence.
}
This renders as:
\indent{
Math \html{\vget[x-over-2]} in a sentence.
}
}

However, hand-writing MathML would be extremely tedious and verbose,
so COWEL offers some convenience directives, listed below.

\h4[id=dir-math]{\dir{math} \c{mdash} Inline math}

A \dir{math} directive surrounds its content with
\ch{<math display=inline>...</math>} tags,
and displays as inline content.

Its content is an HTML context,
and within it, additional pseudo-directives like \dir{mi} or \dir{mn}
corresponding to MathML elements can be used.
Essentially, this allows you to build MathML using COWEL syntax.

See \ref[https://developer.mozilla.org/en-US/docs/Web/MathML/Reference/Element]{Mozilla's MathML elements reference}
for a list of supported elements/directives.

\example{
The previous example in \ref[#math] could also be written like:
\codeblock[cowel]{
Math
\\math{ \\mfrac{\\mi{x}\\mn{2}} }
in a sentence.
}
}

\tip{
If you frequently use math inside plain sentences,
you can define a convenience macro:
\codeblock[cowel]{
\\macro[\\mathsqr{...}]{\\math{\\msup{\\mi{\\put}\\mn{2}}}}

The sum of \\mathsqr{x} and \\mathsqr{y} \c{mldr}
}
This renders as:
\indent{
The sum of \math{\msup{\mi{x}\mn{2}}} and \math{\msup{\mi{y}\mn{2}}} \c{mldr}
}
}

\h4[id=dir-mathblock]{\dir{mathblock} \c{mdash} Math blocks}

The \dir{mathblock} directive functions almost exactly as the \dir{math} directive,
but it displays as block content instead of inline content,
and it produces an opening
\ch{<math display=block>} tag.

\h3{Separators and word breaking}

\h4[id=dir-br]{\dir{br} \c{mdash} Break line}

The \dir{br} directive produces a line break,
and corresponds to the HTML element \ch{<br/>}.
It displays as inline content, and its input content is ignored.

\dir{br} is particularly useful when line breaks are treated same as spaces,
which is the case in most HTML content.

\h4[id=dir-hr]{\dir{hr} \c{mdash} Horizontal rule}

The \dir{hr} directive produces a horizontal rule,
and corresponds to the HTML element \ch{<hr/>}.
It displays as block content, and its input content is ignored.

Here is an example:
\hr

\h4[id=dir-wbr]{\dir{wbr} \c{mdash} Word break opportunity}

The \dir{wbr} directive produces a word break opportunity,
and corresponds to the HTML element \ch{<wbr>}.
It displays as inline content, and its input content is ignored.

\ch{<wbr>} elements can be inserted into the middle of long words,
which, if they don't fit on one line,
will be broken at the point of the \ch{<wbr>} element (without a hyphen at the end of the line).

Since µlight only supports UTF-8 output, \dir{wbr} is equivalent to \cm{\\U{200B}},
which outputs a U+200B ZERO-WIDTH SPACE code point.

\tip{
If you want to provide a word break hint but have a hyphen at the end of the line,
use \cm{\\U{AD}} or \cm{\\c{shy}} to output a U+00AD SOFT HYPHEN.
}

\h4[id=dir-word]{\dir{word} \c{mdash} Unbroken words}

The \dir{word} directive is a formatting directive which prevents word breaks within its content.
Its content is an HTML context.
This is done by applying a \tt[css]{white-space: nowrap;} style its content.

\tip{
Another way to prevent word-breaking is to use non-breaking spaces.
You can insert these using \cm{Combined\\c{nbsp}Word}.
}

\h3{Special characters}

It is quite common that a text document should include special characters.
While COWEL is built on UTF-8,
and in theory one could just write the character directly into the source code,
not every text editor handles special characters well.

To increase portability,
COWEL has the \dir{U} and \dir{c} directives.

\h4{\dir{U} \c{mdash} Code point literal}

The input to a \dir{U} directive is a plaintext context,
which should be a sequence of hexadecimal numbers
specifying a \ref[https://infra.spec.whatwg.org/#scalar-value]{Unicode scalar value};
that is, a code point which UTF-8 permits to be encoded.

\example{
\cm{\\U{30}} generates '\tt{0}' U+0030 DIGIT ZERO
}

\note{
Like anywhere else, directives inside of \dir{U} are allowed.
}

\h4{\dir{c} \c{mdash} Character references}

The input to a \dir{c} directive is a plaintext context,
where the same content is permitted as for HTML character references, aka. HTML entities,
between '\tt{&}' and '\tt{;}'.

\example{
Using \dir{U} and \dir{c}, the '\tt{&}' character can be produced in a number of ways:
\ul{
    \item{Literally '\tt{&}' in text}
    \item{\cm{\\U{26}} (code point literal for U+0026)}
    \item{\cm{\\c{amp}} (like \ch{&amp;}, named character reference)}
    \item{\cm{\\c{#38}} (like \ch{&38;}, decimal character reference)}
    \item{\cm{\\c{#x26}} (like \ch{&x26;}, hexadecimal character reference)}
}
}

In an HTML context, \cm{\\c{xyz}} is literally translated into \ch{&xyz;}.
In a plaintext context, the character reference is mapped onto its corresponding code point(s),
and those code points are output directly.

\note{
Like anywhere else, directives inside of \dir{c} are allowed.
}

\h3{Special blocks}

Often, the content we write falls into some special category like "example", "note", etc.
COWEL supports a large number of \dfn{special block directives},
which wrap their content in a block, with background color, borders, etc.

The input to all special block directives is an HTML context,
they all convert their arguments to HTML attributes,
and they all display as block content.

\h4[id=dir-abstract]{\dir{abstract} \c{mdash} Abstract blocks}

\abstract{
Abstracts provide a summary of the document.
}

\h4[id=dir-blockquote]{\dir{blockquote} \c{mdash} Quote blocks}

The \dir{blockquote} directive directly corresponds to the \ch{<blockquote>} element.

\blockquote{
Quotes blocks or "block quotes" display quoted text.
}

\h4[id=dir-bug]{\dir{bug} \c{mdash} Bug blocks}

\bug{
A bug block contains the description of a bug.
This often includes a code block which demonstrates how to reproduce the bug.
}

\h4[id=dir-decision]{\dir{decision} \c{mdash} Decision blocks}

\decision{
A decision block indicates that a decision needs to be made.
}

\h4[id=dir-delblock]{\dir{delblock} \c{mdash} Deletion blocks}

\delblock{
A deletion block acts as a wrapper for a large amount of deleted content.
It is typically used when individual \dir{del} directives would be too tedious to use.
}

\h4[id=dir-details]{\dir{details} \c{mdash} Details blocks aka spoilers}

The \dir{details} directive directly corresponds to the \ch{<details>} element.
Within \dir{details},
the \dir{summary} directive can be used to specify \dfn{summary text}.

\details{
\summary{This is a summary. Click to open!}
A details block contains details which need to be revealed by the user.
This is also referred to as "spoiler".
}

\h4[id=dir-diff]{\dir{diff} \c{mdash} Difference blocks}

\diff{
A difference block contains changes,
where some content within is typically \del{deleted} or \ins{inserted}.
}

\h4[id=dir-example]{\dir{example} \c{mdash} Example blocks}

\example{
An example block contains examples.
}

\h4[id=dir-insblock]{\dir{insblock} \c{mdash} Insertion blocks}

\insblock{
A deletion block acts as a wrapper for a large amount of inserted content.
It is typically used when individual \dir{ins} directives would be too tedious to use.
}

\h4[id=dir-important]{\dir{important} \c{mdash} Important blocks}

\important{
Important blocks contain especially important information.
}

\h4[id=dir-note]{\dir{note} \c{mdash} Note blocks}

\note{
Note blocks contain less important information,
which can often be skipped over by readers.
}

\h4[id=dir-tip]{\dir{tip} \c{mdash} Tip blocks}

\tip{
Tip blocks contain useful advice.
}

\h4[id=dir-todo]{\dir{todo} \c{mdash} TODO blocks}

\todo{
TODO blocks contain actions that remain to be done.
They may indicate that a part of a project is incomplete.
}

\h4[id=dir-warning]{\dir{warning} \c{mdash} Warning blocks}

\warning{
Warning blocks warn the reader of some hazard or potential mistake.
}

\h3{Lists}

\h4[id=dir-ul]{\dir{ul} \c{mdash} Unordered lists}

The \dir{ul} directive corresponds to the \ch{<ul>} element, and produces an unordered list.
Within that list,
you can use the pseudo-directive \dir{item} to produce list items.

\h4[id=dir-ol]{\dir{ol} \c{mdash} Ordered lists}

The \dir{ol} directive corresponds to the \ch{<ol>} element, and produces an ordered list.
Within that list,
you can use the pseudo-directive \dir{item} to produce list items.

\h4[id=dir-dl]{\dir{dl} \c{mdash} Definition lists}

The \dir{dl} directive corresponds to the \ch{<dl>} element, and produces a definition list.
Within that list, you can use
\ul{
\item{\dir{dt} for \dfn{definition terms}, and}
\item{\dir{dd} for \dfn{definition descriptions}.}
}

\h3{Tables}

Tables are simply produced by using the
\dir{table}, \dir{thead}, \dir{tbody}, \dir{tfoot},
\dir{tr}, \dir{th}, \dir{td},
\dir{colgroup}, \dir{col},
and \dir{caption} directives to
produce the corresponding HTML tags with the same name.

\tip{
To perform advanced styling,
like controlling alignment within columns,
use a \dir{style} directive.
}

\h3{Headings}

Headings can be produced using the
\dir{h1}, \dir{h2}, \dir{h3}, \dir{h4}, \dir{h5}, and \dir{h6} directives to
produce the corresponding HTML tags with the same name.

Arguments to these headings are converted into attributes of the corresponding HTML element.
An \tt{id} argument can be provided explicitly.

If none is provided, an \tt{id} is synthesized from the content within the heading.

\tip{
Headings can be referenced using the \dir{ref} directive:
\codeblock[cowel]{
\\h2{Heading with synthesized id}
\\h2[id=xyz]{Heading with manual id}
\\comment{These can be referenced as follows}
\\ref[#heading-with-synthesized-id]
\\ref[#xzy]
}
}

\h3{References}

\h4[id=dir-ref]{\dir{ref} \c{mdash} References}

The \dir{ref} directive takes a single \tt{to} argument,
which can be a URL, anchor, or something else.
It produces an \ch{<a>} tag with some content inside.

The content is an HTML context, and is what actually gets displayed.
If no content is provided, it can be synthesized from the following types of references:

\ul{
\item{\tt{mailto} URLs (e-mail addresses)}
\item{\tt{tel} URLs (telephone numbers)}
\item{\tt{http} and \tt{https} URLs}
\item{Anchors (\tt{#id}) for some heading in the document}
\item{Anything defined in the bibliography using \dir{bib}}
}

\example{
COWEL markup:
\codeblock[cowel]{
\\ref[mail:john@us.gov]
}
HTML output (\ch{<a>} tag may have additional attributes):
\codeblock[html]{
<a href=mail:john@us.gov>john@us.gov</a>
}
}

\example{
C++ standard draft links can be synthesized into human-readable descriptions.
\codeblock[cowel]{
\\ref[https://eel.is/c++draft/expr#1]
}
This renders as:
\indent{
\ref[https://eel.is/c++draft/expr#1]
}
}

\h4[id=dir-mail]{\dir{mail} \c{mdash} E-Mail addresses}

A \dir{mail} directive behaves the same \dir{ref} directive that is given a \tt{mailto} URL.
However, the input is provided as content instead of an argument,
and the displayed text cannot be customized.

\example{
The following two lines produce the same output:
\codeblock[cowel]{
Please contact \\mail{john@us.gov}.
Please contact \\ref[mailto:john@us.gov].
}
}

\h4[id=dir-tel]{\dir{tel} \c{mdash} Telephone numbers}

A \dir{tel} directive behaves the same \dir{ref} directive that is given a \tt{tel} URL.
However, the input is provided as content instead of an argument,
and the displayed text cannot be customized.

\example{
The following two lines produce the same output:
\codeblock[cowel]{
Please contact \\tel{+1234}.
Please contact \\ref[tel:+1234].
}
}

\h3{Foreign languages}

\h4[id=dir-html]{\dir{html} \c{mdash} Inline HTML}

The \dir{html} directive can be used to output HTML literally.
Its content is a plaintext context,
and it displays as inline content.

\example{
COWEL markup:
\codeblock[cowel]{
This is \\html{<b>bold text</b>}.
}
Generated HTML:
\codeblock[html]{
This is <b>bold text</b>.
}
}

\warning{
The \dir{html} directive can produce malformed HTML content if you're not careful.
See, \ref[#dir-html-element] for a safer option.
}

\h4[id=dir-htmlblock]{\dir{htmlblock} \c{mdash} HTML blocks}

The \dir{htmlblock} directive works exactly like the \dir{html} directive,
but displays as block content instead of inline content.

\warning{
The \dir{htmlblock} directive can produce malformed HTML content if you're not careful.
See, \ref[#dir-html-element] for a safer option.
}

\h4[id=dir-html-element]{\dir{html-*} \c{mdash} HTML element literals}

Any directive beginning with \dir{html-} can be used to produce an HTML element
directly.
Its content is a plaintext context,
and it displays as inline content.
Arguments are converted to HTML attributes of the produced tag.

\example{
COWEL markup:
\codeblock[cowel]{
This is \\html-span[id=abc]{a span}.
}
Generated HTML:
\codeblock[html]{
This is <span id=abc>a span</span>.
}
}

\h4[id=dir-script]{\dir{script} \c{mdash} JavaScript blocks}

The content of a \dir{script} directive is a plaintext context,
where the input is treated as JavaScript code and surrounded in \ch{<script>/*...*/</script>} tags.

\dir{script} displays as meta content (like \dir{comment}).

\example{
COWEL markup:
\codeblock[cowel]{
\\script{
console.log("hello");
}
}
Generated HTML:
\codeblock[html]{
<script>
console.log("hello");
</script>
}
}

\h4[id=dir-noscript]{\dir{noscript} \c{mdash} No-JavaScript content}

The \dir{noscript} directive corresponds to the \ch{<noscript>} element.
Its content is an HTML context,
and will only be shown by the browser when JavaScript is disabled.

\h4[id=dir-style]{\dir{style} \c{mdash} CSS blocks}

The content of a \dir{style} directive is a plaintext context,
where the input is treated as JavaScript code and surrounded in \ch{<style>/*...*/</style>} tags.

\dir{style} displays as meta content (like \dir{comment}).

\example{
COWEL markup:
\codeblock[cowel]{
\\style{
body { color: red; }
}
}
Generated HTML:
\codeblock[html]{
<style>
body { color: red; }
</style>
}
}

\h3{Paragraph control}

In some cases, the automatic \ref[#paragraph-splitting]
process is not enough.
To get more fine-tuned control, we have a number of directives.

\h4[id=dir-p]{\dir{p} \c{mdash} Paragraphs}

The \dir{p} directive surrounds its content in \ch{<p>...</p>} tags.

\h4[id=dir-paragraphs]{\dir{paragraphs} \c{mdash} Enable paragraph splitting}

The \dir{paragraphs} directive activates paragraph splitting.
This may be useful in places where it is not active by default.

\example{
COWEL markup:
\codeblock[cowel]{
\\ul{
\\item{\\paragraphs{
First paragraph in bullet.

Second paragraph.
}}
}
}
Generated HTML:
\codeblock[html]{
<ul>
<li>
<p>First paragraph in bullet.</p>

<p>Second paragraph in bullet.</p>
</li>
</ul>
}
}

\h4[id=dir-block]{\dir{block} \c{mdash} Display as block content}

The \dir{block} directive doesn't add any HTML itself,
but causes its contents to be considered block content.

\example{
\dir{block} can be used to suppress automatic paragraph splitting:
\codeblock[cowel]{
\\comment{No <p> tags will be added here}
\\block{
First paragraph.

Second paragraph.
}
}
}

\h4[id=dir-inline]{\dir{inline} \c{mdash} Display as inline content}

The \dir{inline} directive works like the \dir{block} directive,
but causes its contents to display as inline content, not as block content.

\h3{Sections}

Often, you want to produce content in one place,
but have it display in another place within the document.
A classic example is collecting headings automatically in a table of contents,
or copying the content of a heading into a preview when referenced by \cm{\\ref[#id]}.

\h4[id=dir-there]{\dir{there} \c{mdash} Append content to section}

The \dir{there} directive displays as meta content.
Basically, it stashes away its input content (which is an HTML context) somewhere else.

It takes a single \tt{section} argument which specifies the name of the section.
The \tt{section} argument is a plaintext context.

By default, all document content is placed within a \ch{<main>} element,
inside \ch{<body>}, inside \ch{html}.
\dir{there} allows you to write outside of the \ch{<main>} element:

\ul{
\item{
\cm{\\there[std.head]{text}} will write \cm{text}
inside of the \ch{<head>} element (following auto-generated content).
}
\item{
\cm{\\there[std.body]{text}} will write \cm{text}
inside of the \ch{<body>} element (following \ch{<main>}
and other automatically inserted elements).
}
}

\tip{
You can change the title of the document as follows:
\codeblock[cowel]{
\\there[std.head]{
\\html-title{This is the document title!}
}
}
}

\h4[id=dir-here]{\dir{here} \c{mdash} Copy section content}

The \dir{here} directive inserts the content from another section at its location.
It displays as inline content.

It takes a single \tt{section} argument which specifies the name of the section.
The \tt{section} argument is a plaintext context.

All references produced by \dir{here} are resolved in a post-processing step,
which allows forward-references.

\example{
COWEL markup:
\codeblock[cowel]{
\\there[sec]{before/}
(\\here[sec])
\\there[sec]{/after}
}
Generated HTML:
\codeblock[html]{
(before//after)
}
}

\h4[id=dir-hereblock]{\dir{hereblock} \c{mdash} Copy section content in block}

The \dir{hereblock} directive functions exactly like the \dir{here} directive,
but displays as block content instead of inline content.

\h3{Macros}

\h4[id=dir-def]{\dir{macro} \c{mdash} Define a macro}

The \dir{macro} directive defines a \dfn{macro},
which is basically a user-defined directive.
It has a single \tt{pattern} argument,
which shall be a single \dfn{pattern directive} which describes the defined directive.

\note{
The arguments and content of the pattern directive are not processed,
but can be used to document how the directive is meant to be used.
\codeblock[cowel]{
\\comment{The following two definitions are equivalent:}
\\macro[\\m{...}]{xyz}
\\macro[\\m]{xyz}
}
}

When a macro is used, the content within the \dir{macro} directive is copied.
Any uses of the \dir{put} pseud-directive inside the macro are replaced with copies
of the input content.

\example{
\codeblock[cowel]{
\\macro[\\bi]{\\b{\\i{\\put}}}
\\comment{Now, the following are equivalent:}
\\b{\\i{bold and italic}}
\\bi{bold and italic}
}
}

\todo{
Currently, macros only support content as input.
Arguments to macros are ignored entirely.
This should be supported at some point.
}
